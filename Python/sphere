#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Sat Jan  5 15:41:33 2019
/
@author: diana
"""
import random
import numpy as np 
from random import randrange
#define a plane to project the points. Range1 = from , Range2=to . 
def plane(range1,range2):
    p1 = np.array([randrange(range1,range2), randrange(range1,range2), randrange(range1,range2)])
    p2 = np.array([randrange(range1,range2),randrange(range1,range2), randrange(range1,range2)])
    p3 = np.array([randrange(range1,range2), randrange(range1,range2), randrange(range1,range2)])
    v1 = p3 - p1
    v2 = p2 - p1
    cp = np.cross(v1, v2)
    a, b, c = cp
    d = np.dot(cp, p3)
    return a, b, c, d  #now we have plane a,b,c,d to find t

#use worldpoints to find the imagepoints and the convert to u.v homogeneous
def spherepoints(points):
    worldpoints = np.random.randn(3, points)
    worldpoints /= np.linalg.norm(worldpoints, axis=0)
    return worldpoints

def projection(planecoord,worldpoints):
    for i in range(6):
#now I have a,b,c,d so I can calculate t
     t=-(planecoord[0]*worldpoints[i,0]+planecoord[1]*worldpoints[i,1]+planecoord[2]*worldpoints[i,2]+planecoord[3])/(planecoord[0]**2+planecoord[1]**2+planecoord[2]**2)
     projectpoints[i,0]=planecoord[0]*t+worldpoints[i,0]
     projectpoints[i,1]=planecoord[1]*t+worldpoints[i,1]
     projectpoints[i,2]=planecoord[2]*t+worldpoints[i,2]
     imagepoints[i,0]= projectpoints[i,0] / projectpoints[i,2]#convert to u homogeneous
     imagepoints[i,1] = projectpoints[i,1] / projectpoints[i,2]#convert to v homogeneous
    return imagepoints
 
def DLT3D(worldpoints, imagepoints, normalize=False):
    if (normalize):
        l = 0
        for j in range(12):
            if ((j % 2) == 0):                    #if even 0,0,0,0,xi,yi,zi,1,-vixi,-viyi,-vizi,-vi
                for k in range(4):
                            A[j, k] = 0
                A[j,4] = worldpoints[l,0]
                A[j,5] = worldpoints[l,1]
                A[j,6] = worldpoints[l,2]
                A[j,7] = 1
                A[j, 8] = -imagepoints[l, 1] * worldpoints[l,0]
                A[j, 9] = -imagepoints[l, 1] * worldpoints[l,1]
                A[j, 10] = -imagepoints[l, 1] * worldpoints[l,2]
                A[j, 11] = -imagepoints[l, 1]
            else :
             for k in range(4,8):
                A[j, k]= 0
             A[j,0] = worldpoints[l,0]
             A[j,1]= worldpoints[l,1]
             A[j,2] = worldpoints[l,2]
             A[j,3] = 1
             A[j, 8] = -imagepoints[l, 0] * worldpoints[l,0]
             A[j, 9] = -imagepoints[l, 0] * worldpoints[l,1]
             A[j, 10] = -imagepoints[l, 0] * worldpoints[l,2]
             A[j, 11] = -imagepoints[l, 0]
             l = l + 1
        U, s, V = np.linalg.svd(A, full_matrices=True)
        for i in range(12):
           M[i]=V[i,11]
        T[2]=M[11]/K[2,2]
        T[1]=(M[7]-K[1,2]*T[2])/K[1,1] 
        T[0]=(M[3]-K[0,1]*T[1]-K[0,2]*T[2])/K[0,0]
        for i in range(3):
          R[2,i]=M[i+8]/K[2,2]  #fr3i=m3i
          R[1,i]=(M[i+4]- R[2,i]*K[1,2])/K[1,1];  #dr2i+er3i=m2,i
          R[0,i]= (M[i]-K[0,2]*R[2,i]-K[0,1]*R[1,i])/K[0,0]; #ar1i+br2i+cr3i=m1i
        return T,R       
    else:
        normp= np.linalg.norm(imagepoints)
        pnorm=imagepoints/normp
        return DLT3D(worldpoints,pnorm, normalize=True)
       
def k_matrix(fx=1 , fy=1, cx=0 , cy=0):
 fx=random.randrange(0,1)
 fy=random.randrange(0,1)
 cx=random.randrange(0,1)
 cy=random.randrange(0,1)       
 K= np.mat([[fx, 0, cx],
            [0,fy,cy],
            [0,0,1.]], dtype=np.float32) 
 return K

worldpoints = spherepoints(6)
imagepoints=np.full((6, 2), 0.0)
A=np.full((12, 12), 0.0)
M=np.full((12, 1), 0.0)
T=np.full((3), 0.0)
R=np.full((3,3), 0.0)
projectpoints=np.full((6, 3), 0.0)


#NoNoiseTest
planecoord=plane(random.randint(-50,50), random.randint(-50,50))    
imagepoints=projection(planecoord,worldpoints)
T,R=DLT3D(worldpoints, imagepoints)

#NoiseTest
imagepoints=projection(planecoord,worldpoints)
imagepoints_noise=imagepoints+np.random.normal(-10,10)
Tnoise,Rnoise=DLT3D(worldpoints, imagepoints)
   
    

 


    


