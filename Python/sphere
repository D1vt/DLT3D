#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Sat Jan  5 15:41:33 2019
/
@author: diana
@set_P, set_K, set_R_axisAngle, set_t developed by raultron
"""
import numpy as np 
from random import randrange
from numpy import linalg as LA
from scipy.linalg import expm, inv
import math

def set_P(K,Rt):
        # P = K[R|t]
        # P is a 3x4 Projection Matrix (from 3d euclidean to image)
        #self.Rt = hstack((self.R, self.t))
        P = np.dot(K,Rt[:3,:4])
        return P
    
def set_K( Rt, fx = 1, fy = 1, cx = 0,cy = 0):
        # K is the 3x3 Camera matrix
        # fx, fy are focal lenghts expressed in pixel units
        # cx, cy is a principal point usually at image center
        K = np.mat([[fx, 0, cx],
                      [0,fy,cy],
                      [0,0,1.]], dtype=np.float32)
        P=set_P(K,Rt)    
        return K,P



def project(worldpoints, P, imagePoints, quant_error=False):
        """  Project points in X (6*n array) & convert to homogeneous"""
        
        
        for i in range(6):
            X=worldpoints[i,0]
            Y=worldpoints[i,1]
            Z=worldpoints[i,2]
            x=P[0,0]*X+P[0,1]*Y+P[0,2]*Z+P[0,3]
            y=P[1,0]*X+P[1,1]*Y+P[1,2]*Z+P[1,3]
            z=P[2,0]*X+P[2,1]*Y+P[2,2]*Z+P[2,3]
            imagePoints[i,0]=x/z
            imagePoints[i,1]=y/z
            
        #for i in range(x.shape[1]):
         # x[:,i] /= x[2,i]
        if(quant_error):
            imagePoints = np.around(imagePoints, decimals=0)
        return imagePoints    

def set_R_axisAngle(x,y,z, alpha,K,t):
        """  Creates a 3D [R|t] matrix for rotation
        around the axis of the vector defined by (x,y,z)
        and an alpha angle."""
        #Normalize the rotation axis a
        a = np.array([x,y,z])
        a = a / np.linalg.norm(a)
        a_skew = np.mat([[0,-a[2],a[1]], [a[2], 0, -a[0]], [-a[1], a[0], 0]])
        R = np.eye(4)
        R[:3,:3] = expm(a_skew*alpha)
        Rt=update_Rt(R,t)
        P=set_P(K,Rt)
        return R,P
  
def set_t(x,y,z,K,R, frame = 'camera'):
        #self.t = array([[x],[y],[z]])
        t = np.eye(4)
        if frame=='world':
          cam_world = np.array([x,y,z,1]).T
          cam_t = np.dot(R,-cam_world)
          t[:3,3] = cam_t[:3]
        else:
          t[:3,3] = np.array([x,y,z])
        Rt=update_Rt(R,t)
        P=set_P(K,Rt)
        return t,P

def update_Rt(R,t):
    Rt=np.dot(R,t)
    return Rt

def set_T_Rt(trans,R):
    B=np.full((3, 3), 0.0)
    for i in range(3):
        B[i,1]=R[i,0]
        B[i,1]=R[i,1]
        B[i,2]=R[i,2]
        B[i,3]=trans[i]
    B[3,3]=1
    return B 

def spherepoints(points):
    worldpoints = np.random.randn(points, 3)
    worldpoints /= np.linalg.norm(worldpoints, axis=0)
    return worldpoints

def normalize(imagePoints):
    normp= np.linalg.norm(imagePoints)
    imagePoints=imagePoints/normp
    return imagePoints               

def DLT3D(worldpoints, imagepoints, K, normalization=False):
    A=np.full((12, 12), 0.0)
    M=np.full((12, 1), 0.0)
    if (normalize):
        l = 0
        for j in range(12):
            if ((j % 2) == 0):                    #if even 0,0,0,0,xi,yi,zi,1,-vixi,-viyi,-vizi,-vi
                for k in range(4):
                            A[j, k] = 0
                A[j,4] = worldpoints[l,0]
                A[j,5] = worldpoints[l,1]
                A[j,6] = worldpoints[l,2]
                A[j,7] = 1
                A[j, 8] = -imagepoints[l, 1] * worldpoints[l,0]
                A[j, 9] = -imagepoints[l, 1] * worldpoints[l,1]
                A[j, 10] = -imagepoints[l, 1] * worldpoints[l,2]
                A[j, 11] = -imagepoints[l, 1]
            else :
             for k in range(4,8):
                A[j, k]= 0
             A[j,0] = worldpoints[l,0]
             A[j,1]= worldpoints[l,1]
             A[j,2] = worldpoints[l,2]
             A[j,3] = 1
             A[j, 8] = -imagepoints[l, 0] * worldpoints[l,0]
             A[j, 9] = -imagepoints[l, 0] * worldpoints[l,1]
             A[j, 10] = -imagepoints[l, 0] * worldpoints[l,2]
             A[j, 11] = -imagepoints[l, 0]
             l = l + 1
        U, s, V = np.linalg.svd(A, full_matrices=True)
        for v in range(12):
           M[v]=V[v,11]
        trans[2]=M[11]/K[2,2]
        trans[1]=(M[7]-K[1,2]*trans[2])/K[1,1]
        trans[0]=(M[3]-K[0,1]*trans[1]-K[0,2]*trans[2])/K[0,0]
        for j in range(4):
            H[0,j]=M[j]
            H[1,j]=M[j+4]
            H[2,j]=M[j+8]              
        for i in range(3):
          Rot[2,i]=M[i+8]/K[2,2]  #fr3i=m3i
          Rot[1,i]=(M[i+4]- Rot[2,i]*K[1,2])/K[1,1];  #dr2i+er3i=m2,i
          Rot[0,i]= (M[i]-K[0,2]*Rot[2,i]-K[0,1]*Rot[1,i])/K[0,0]; #ar1i+br2i+cr3i=m1i
        return trans,Rot,H       
    else:
        pnorm=normalize(imagepoints)
        return DLT3D(worldpoints,pnorm, K, True)
    
    
def add_noise(imagePoints,sd,mean):
    gauss_noise= np.random.normal(mean,sd)
    imagePoints=imagePoints+gauss_noise
    return imagePoints           

#values
P = np.eye(3,4)
R = np.eye(4, dtype=np.float32) # rotatio
t = np.eye(4, dtype=np.float32) # translation
Rt = np.eye(4, dtype=np.float32)

K,P=set_K(Rt,fx = 600, fy = 600, cx = 320, cy = 240)
R,P=set_R_axisAngle(1.0,  0.0,  0.0, np.deg2rad(180.0),K,t)
t,P=set_t(0.0,-0.0,0.5,K,R, frame='world')


worldpoints = spherepoints(6)
imagePoints=np.full((6,2),0.0)
imagePoints = project(worldpoints,P,imagePoints, False)
imagePoints=normalize(imagePoints)
imagepoints_noise=add_noise(imagePoints,2,0)



H= np.full((3,4),0.0)
trans=np.full((3,1), 0.0)
Rot=np.full((3,3), 0.0)

#NoNoiseTest
trans,Rot,H=DLT3D(worldpoints, imagePoints, K, True)
cond2=LA.cond(H)

#NoiseTest
trans,Rot,H=DLT3D(worldpoints, imagepoints_noise, K)
condnoise=LA.cond(H)  
