#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Sat Jan  5 15:41:33 2019
/
@author: diana
@set_P, set_K, set_R_axisAngle, set_t developed by raultron
"""
import numpy as np 
from random import randrange
from numpy import linalg as LA
from scipy.linalg import expm, inv
import math
import numdifftools as nd

def set_P(K,Rt):
        # P = K[R|t]
        # P is a 3x4 Projection Matrix (from 3d euclidean to image)
        #self.Rt = hstack((self.R, self.t))
        P = np.dot(K,Rt[:3,:4])
        return P
    
def set_K( Rt, fx = 1, fy = 1, cx = 0,cy = 0):
        # K is the 3x3 Camera matrix
        # fx, fy are focal lenghts expressed in pixel units
        # cx, cy is a principal point usually at image center
        K = np.mat([[fx, 0, cx],
                      [0,fy,cy],
                      [0,0,1.]], dtype=np.float32)
        P=set_P(K,Rt)    
        return K,P



def project(worldpoints, P, imagePoints, quant_error=False):
        """  Project points in X (6*n array) & convert to homogeneous"""
        
        
        for i in range(6):
            X=worldpoints[i,0]
            Y=worldpoints[i,1]
            Z=worldpoints[i,2]
            x=P[0,0]*X+P[0,1]*Y+P[0,2]*Z+P[0,3]
            y=P[1,0]*X+P[1,1]*Y+P[1,2]*Z+P[1,3]
            z=P[2,0]*X+P[2,1]*Y+P[2,2]*Z+P[2,3]
            imagePoints[i,0]=x/z
            imagePoints[i,1]=y/z
            
        #for i in range(x.shape[1]):
         # x[:,i] /= x[2,i]
        if(quant_error):
            imagePoints = np.around(imagePoints, decimals=0)
        return imagePoints    

def set_R_axisAngle(x,y,z, alpha,K,t):
        """  Creates a 3D [R|t] matrix for rotation
        around the axis of the vector defined by (x,y,z)
        and an alpha angle."""
        #Normalize the rotation axis a
        a = np.array([x,y,z])
        a = a / np.linalg.norm(a)
        a_skew = np.mat([[0,-a[2],a[1]], [a[2], 0, -a[0]], [-a[1], a[0], 0]])
        R = np.eye(4)
        R[:3,:3] = expm(a_skew*alpha)
        Rt=update_Rt(R,t)
        P=set_P(K,Rt)
        return R,P
  
def set_t(x,y,z,K,R, frame = 'camera'):
        #self.t = array([[x],[y],[z]])
        t = np.eye(4)
        if frame=='world':
          cam_world = np.array([x,y,z,1]).T
          cam_t = np.dot(R,-cam_world)
          t[:3,3] = cam_t[:3]
        else:
          t[:3,3] = np.array([x,y,z])
        Rt=update_Rt(R,t)
        P=set_P(K,Rt)
        return t,P

def update_Rt(R,t):
    Rt=np.dot(R,t)
    return Rt
#Create T=[R|t]
def set_afterDLT_Rt(trans,R):
    B=np.full((4, 4), 0.0)
    for i in range(3):
        B[i,0]=R[i,0]
        B[i,1]=R[i,1]
        B[i,2]=R[i,2]
        B[i,3]=trans[i]
    B[3,3]=1
    return B 

def spherepoints(points):
    worldpoints = np.random.randn(points, 3)
    worldpoints /= np.linalg.norm(worldpoints, axis=0)
    return worldpoints

def normalize(imagePoints):
    normp= np.linalg.norm(imagePoints)
    imagePoints=imagePoints/normp
    return imagePoints               

def DLT3D(worldpoints, imagepoints, K, normalization=False):
    A=np.full((12, 12), 0.0)
    M=np.full((12, 1), 0.0)
    if (normalize):
        l = 0
        for j in range(12):
            if ((j % 2) == 0):                    #if even 0,0,0,0,xi,yi,zi,1,-vixi,-viyi,-vizi,-vi
                for k in range(4):
                            A[j, k] = 0
                A[j,4] = worldpoints[l,0]
                A[j,5] = worldpoints[l,1]
                A[j,6] = worldpoints[l,2]
                A[j,7] = 1
                A[j, 8] = -imagepoints[l, 1] * worldpoints[l,0]
                A[j, 9] = -imagepoints[l, 1] * worldpoints[l,1]
                A[j, 10] = -imagepoints[l, 1] * worldpoints[l,2]
                A[j, 11] = -imagepoints[l, 1]
            else :
             for k in range(4,8):
                A[j, k]= 0
             A[j,0] = worldpoints[l,0]
             A[j,1]= worldpoints[l,1]
             A[j,2] = worldpoints[l,2]
             A[j,3] = 1
             A[j, 8] = -imagepoints[l, 0] * worldpoints[l,0]
             A[j, 9] = -imagepoints[l, 0] * worldpoints[l,1]
             A[j, 10] = -imagepoints[l, 0] * worldpoints[l,2]
             A[j, 11] = -imagepoints[l, 0]
             l = l + 1
        U, s, V = np.linalg.svd(A, full_matrices=True)
        for v in range(12):
           M[v]=V[v,11]
        trans[2]=M[11]/K[2,2]
        trans[1]=(M[7]-K[1,2]*trans[2])/K[1,1]
        trans[0]=(M[3]-K[0,1]*trans[1]-K[0,2]*trans[2])/K[0,0]
        for j in range(4):
            H[0,j]=M[j]
            H[1,j]=M[j+4]
            H[2,j]=M[j+8]              
        for i in range(3):
          Rot[2,i]=M[i+8]/K[2,2]  #fr3i=m3i
          Rot[1,i]=(M[i+4]- Rot[2,i]*K[1,2])/K[1,1];  #dr2i+er3i=m2,i
          Rot[0,i]= (M[i]-K[0,2]*Rot[2,i]-K[0,1]*Rot[1,i])/K[0,0]; #ar1i+br2i+cr3i=m1i
        return trans,Rot,H       
    else:
        pnorm=normalize(imagepoints)
        return DLT3D(worldpoints,pnorm, K, True)
    
    
def add_noise(imagePoints,sd=4,mean=0):
    gauss_noise= np.random.normal(mean,sd)
    imagePoints=imagePoints+gauss_noise
    return imagePoints           
    
    
   ### here we solve the problem using shperical coordinates and Euler angles


def a_b_c_from_Euler(Rot,Rt):
    world_position = get_world_position(Rt)  #[x,y,z,1]
    x = world_position[0]
    y = world_position[1]
    z = world_position[2]
    r = np.sqrt(x * x + y * y + z * z,dtype=np.float32)
    if r ==0:
        a = np.deg2rad(0.0)
    else:
        a = math.acos(z / r)
    if x == 0:
        b = np.deg2rad(90.0)
    else:
       b = math.atan(y / x)
    return a,b,r

def covariance_matrix_p(K,Rot,Rt,worldpoints,imagePoints):
    #xyz_sphere=xyz_sphere(a,b,r)
    a,b,c=a_b_c_from_Euler(Rot,Rt)
    Jac=jacobian_matrix(a,b,c,K,worldpoints)
    print Jac
    mean = 0.0
    scale = 4.0 
    size = 10000
    px1 = np.random.normal(mean, scale, size) + imagePoints[0, 0]
    py1 = np.random.normal(mean, scale, size) + imagePoints[0, 1]
    # Point 2
    px2 = np.random.normal(mean, scale, size) + imagePoints[1, 0]
    py2 = np.random.normal(mean, scale, size) + imagePoints[1, 1]
    # Point 3
    px3 = np.random.normal(mean, scale, size) + imagePoints[2, 0]
    py3 = np.random.normal(mean, scale, size) + imagePoints[2, 1]
    # Point 4
    px4 = np.random.normal(mean, scale, size) + imagePoints[3, 0]
    py4 = np.random.normal(mean, scale, size) + imagePoints[3, 1]
    # Point 5
    px5 = np.random.normal(mean, scale, size) + imagePoints[4, 0]
    py5 = np.random.normal(mean, scale, size) + imagePoints[4, 1]
    # Point 6
    px6 = np.random.normal(mean, scale, size) + imagePoints[5, 0]
    py6 = np.random.normal(mean, scale, size) + imagePoints[5, 1]
    
    #imagePoints=add_noise(imagePoints)
    #imagePoints=normalize(imagePoints)
    cov_mat_p1 = np.cov(px1,py1)
    print cov_mat_p1
    cov_mat_p2 = np.cov(px2,py2)
    cov_mat_p3 = np.cov(px3,py3)
    cov_mat_p4 = np.cov(px4,py4)
    cov_mat_p5 = np.cov(px5,py5)
    cov_mat_p6 = np.cov(px6,py6)
    
    
    
    image6points = np.block([[cov_mat_p1, np.zeros((2, 2)), np.zeros((2, 2)), np.zeros((2, 2)), np.zeros((2, 2)), np.zeros((2, 2))],
                                      [np.zeros((2, 2)), cov_mat_p2, np.zeros((2, 2)), np.zeros((2, 2)), np.zeros((2, 2)), np.zeros((2, 2))],
                                       [np.zeros((2, 2)), np.zeros((2, 2)), cov_mat_p3, np.zeros((2, 2)),np.zeros((2, 2)),np.zeros((2, 2))],
                                       [np.zeros((2, 2)), np.zeros((2, 2)),np.zeros((2, 2)),cov_mat_p4, np.zeros((2, 2)), np.zeros((2, 2))],
                                       [np.zeros((2, 2)), np.zeros((2, 2)),np.zeros((2, 2)),np.zeros((2, 2)), cov_mat_p5, np.zeros((2, 2))],
                                       [np.zeros((2, 2)), np.zeros((2, 2)),np.zeros((2, 2)),np.zeros((2, 2)), np.zeros((2, 2)), cov_mat_p6]])
    image6points=np.diag(np.diag( image6points))
    #cov_matrix=np.dot(np.transpose(Jac),inv(image6points))
    #cov_matrix= inv(np.dot(np.dot(np.transpose(Jac), inv(image6points)), Jac))
    return image6points #cov_matrix

def R_Euler(a,b,c):
    R_Euler= np.array([[math.cos(a)*math.cos(c) - math.cos(b)*math.sin(a)*math.sin(c), -math.cos(a)*math.sin(c)-math.cos(b)*math.cos(c)*math.sin(a), math.sin(a)*math.sin(b)],
                       [math.cos(c)*math.sin(a)+math.cos(a)*math.cos(b)*math.sin(c), math.cos(a)*math.cos(b)*math.cos(c)-math.sin(a)*math.sin(c), -math.cos(a)*math.sin(b)],
                       [math.sin(b)*math.sin(c), math.cos(c)*math.sin(b), math.cos(b)]])
    return R_Euler
def p_nonlinear(a,b,c,K,X):
    R_Sphere = np.array([[math.cos(b)*math.cos(a), -math.sin(b), math.cos(b)*math.sin(a)],
                          [math.sin(b)*math.cos(a), math.cos(b), math.cos(b)*math.sin(a)],
                          [-math.sin(a), 0, math.cos(a)]])
    R_Eu= R_Euler(0.0,np.deg2rad(180.0),0.0)
    R_Sphere = np.dot(R_Sphere, R_Eu[:3, :3]) 
    t_Sphere= np.array([[c*math.sin(a)*math.cos(b)],
               [c*math.sin(b)*math.sin(a)],
               [c*math.cos(a)]])
    t_Sphere=np.dot(R_Sphere, -t_Sphere)
    Rt_Sphere=np.hstack((R_Sphere, t_Sphere))
    P=np.dot(K,Rt_Sphere)
    Y=np.array([[X[0]],
                [X[1]],
                [X[2]],
                [1]])
    image_point = np.dot(P,Y)
    p=np.full((1,2),0.0)
    p[0,0] = image_point[0]/image_point[2]
    p[0,1] = image_point[1]/image_point[2]
    return p
    


def get_world_position(Rt):
        w_pos = np.dot(inv(Rt), np.array([0,0,0,1]))
        return w_pos


def jacobian_matrix(a,b,c,K,worldpoints):
     point1=nd.Jacobian(p_nonlinear(a,b,c, K, worldpoints[0, :]))
     point2=nd.Jacobian(p_nonlinear(a,b,c, K, worldpoints[1, :]))
     point3=nd.Jacobian(p_nonlinear(a,b,c, K, worldpoints[2, :]))
     point4=nd.Jacobian(p_nonlinear(a,b,c, K, worldpoints[3, :]))
     point5=nd.Jacobian(p_nonlinear(a,b,c, K, worldpoints[4, :]))
     point6=nd.Jacobian(p_nonlinear(a,b,c, K, worldpoints[5, :]))
     Jac=np.vstack((point1,point2,point3,point4,point5,point6))
     return Jac 
      
    
   #na brw to p για να εκτιμησω το σφαλμα γιατι απο π παιρνω το τζακομπιαν
        
#values
P = np.eye(3,4)
R = np.eye(4, dtype=np.float32) # rotatio
t = np.eye(4, dtype=np.float32) # translation
Rt = np.eye(4, dtype=np.float32)

K,P=set_K(Rt,fx = 600, fy = 600, cx = 320, cy = 240)
R,P=set_R_axisAngle(1.0,  0.0,  0.0, np.deg2rad(180.0),K,t)
t,P=set_t(0.0,-0.0,0.5,K,R, frame='world')


worldpoints = spherepoints(6)
#testpoints
#worldpoints = np.array([[-0.206674, 0.240009,-0.29203],
#                        [0.091502,-0.144823,	0.0323819],
 #                       [0.371293,	-0.458251	,0.269246],
  #                      [-0.864962	,0.222202	,0.0354375],
   #                     [-0.211795	,0.418585	,0.491078],
    #                    [-0.134308	,0.69774,	-0.773798]])

imagePoints=np.full((6,2),0.0)
imagePoints = project(worldpoints,P,imagePoints, False)
imagePoints=normalize(imagePoints)
imagepoints_noise=add_noise(imagePoints,2,0)



H= np.full((3,4),0.0)
trans=np.full((3,1), 0.0)
Rot=np.full((3,3), 0.0)

#NoNoiseTest
trans,Rot,H=DLT3D(worldpoints, imagePoints, K, True)
cond2=LA.cond(H)

#NoiseTest
trans,Rot,H=DLT3D(worldpoints, imagepoints_noise, K)
condnoise=LA.cond(H)   
#covnoise=np.cov(H)
 
Rt=set_afterDLT_Rt(trans,Rot)

covmatrix=covariance_matrix_p(K,Rot,Rt,worldpoints,imagePoints)
    

