#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Sat Jan  5 15:41:33 2019
/
@author: diana
@set_P, set_K, set_R_axisAngle, set_t developed by raultron
"""
import numpy as np 
from random import randrange
from numpy import linalg as LA
from scipy.linalg import expm, inv
import math
import algopy
import numdifftools as nd

def set_P(K,Rt):
        # P = K[R|t]
        # P is a 3x4 Projection Matrix (from 3d euclidean to image)
        #self.Rt = hstack((self.R, self.t))
        P = np.dot(K,Rt[:3,:4])
        return P
    
def set_K( Rt, fx = 1, fy = 1, cx = 0,cy = 0):
        # K is the 3x3 Camera matrix
        # fx, fy are focal lenghts expressed in pixel units
        # cx, cy is a principal point usually at image center
        K = np.mat([[fx, 0, cx],
                      [0,fy,cy],
                      [0,0,1.]], dtype=np.float32)
        P=set_P(K,Rt)    
        return K,P



def project(worldpoints, P, imagePoints, quant_error=False):
        """  Project points in X (6*n array) & convert to homogeneous"""
        
        
        for i in range(6):
            X=worldpoints[i,0]
            Y=worldpoints[i,1]
            Z=worldpoints[i,2]
            x=P[0,0]*X+P[0,1]*Y+P[0,2]*Z+P[0,3]
            y=P[1,0]*X+P[1,1]*Y+P[1,2]*Z+P[1,3]
            z=P[2,0]*X+P[2,1]*Y+P[2,2]*Z+P[2,3]
            imagePoints[i,0]=x/z
            imagePoints[i,1]=y/z
            
        #for i in range(x.shape[1]):
         # x[:,i] /= x[2,i]
        if(quant_error):
            imagePoints = np.around(imagePoints, decimals=0)
        return imagePoints    

def set_R_axisAngle(x,y,z, alpha,K,t):
        """  Creates a 3D [R|t] matrix for rotation
        around the axis of the vector defined by (x,y,z)
        and an alpha angle."""
        #Normalize the rotation axis a
        a = np.array([x,y,z])
        a = a / np.linalg.norm(a)
        a_skew = np.mat([[0,-a[2],a[1]], [a[2], 0, -a[0]], [-a[1], a[0], 0]])
        R = np.eye(4)
        R[:3,:3] = expm(a_skew*alpha)
        Rt=update_Rt(R,t)
        P=set_P(K,Rt)
        return R,P
  
def set_t(x,y,z,K,R, frame = 'camera'):
        #self.t = array([[x],[y],[z]])
        t = np.eye(4)
        if frame=='world':
          cam_world = np.array([x,y,z,1]).T
          cam_t = np.dot(R,-cam_world)
          t[:3,3] = cam_t[:3]
        else:
          t[:3,3] = np.array([x,y,z])
        Rt=update_Rt(R,t)
        P=set_P(K,Rt)
        return t,P

def update_Rt(R,t):
    Rt=np.dot(R,t)
    return Rt
#Create T=[R|t]
def set_afterDLT_Rt(trans,R):
    B=np.full((4, 4), 0.0)
    for i in range(3):
        B[i,0]=R[i,0]
        B[i,1]=R[i,1]
        B[i,2]=R[i,2]
        B[i,3]=trans[i]
    B[3,3]=1
    return B 

def spherepoints(points):
    worldpoints = np.random.randn(points, 3)
    worldpoints /= np.linalg.norm(worldpoints, axis=0)
    return worldpoints

def normalize(imagePoints):
    normp= np.linalg.norm(imagePoints)
    imagePoints=imagePoints/normp
    return imagePoints               

def DLT3D(worldpoints, imagepoints, K, normalization=False):
    A=np.full((12, 12), 0.0)
    M=np.full((12, 1), 0.0)
    if (normalize):
        l = 0
        for j in range(12):
            if ((j % 2) == 0):                    #if even 0,0,0,0,xi,yi,zi,1,-vixi,-viyi,-vizi,-vi
                for k in range(4):
                            A[j, k] = 0
                A[j,4] = worldpoints[l,0]
                A[j,5] = worldpoints[l,1]
                A[j,6] = worldpoints[l,2]
                A[j,7] = 1
                A[j, 8] = -imagepoints[l, 1] * worldpoints[l,0]
                A[j, 9] = -imagepoints[l, 1] * worldpoints[l,1]
                A[j, 10] = -imagepoints[l, 1] * worldpoints[l,2]
                A[j, 11] = -imagepoints[l, 1]
            else :
             for k in range(4,8):
                A[j, k]= 0
             A[j,0] = worldpoints[l,0]
             A[j,1]= worldpoints[l,1]
             A[j,2] = worldpoints[l,2]
             A[j,3] = 1
             A[j, 8] = -imagepoints[l, 0] * worldpoints[l,0]
             A[j, 9] = -imagepoints[l, 0] * worldpoints[l,1]
             A[j, 10] = -imagepoints[l, 0] * worldpoints[l,2]
             A[j, 11] = -imagepoints[l, 0]
             l = l + 1
        U, s, V = np.linalg.svd(A, full_matrices=True)
        for v in range(12):
           M[v]=V[v,11]
        trans[2]=M[11]/K[2,2]
        trans[1]=(M[7]-K[1,2]*trans[2])/K[1,1]
        trans[0]=(M[3]-K[0,1]*trans[1]-K[0,2]*trans[2])/K[0,0]
        for j in range(4):
            H[0,j]=M[j]
            H[1,j]=M[j+4]
            H[2,j]=M[j+8]              
        for i in range(3):
          Rot[2,i]=M[i+8]/K[2,2]  #fr3i=m3i
          Rot[1,i]=(M[i+4]- Rot[2,i]*K[1,2])/K[1,1];  #dr2i+er3i=m2,i
          Rot[0,i]= (M[i]-K[0,2]*Rot[2,i]-K[0,1]*Rot[1,i])/K[0,0]; #ar1i+br2i+cr3i=m1i
        return trans,Rot,H       
    else:
        pnorm=normalize(imagepoints)
        return DLT3D(worldpoints,pnorm, K, True)
    
    
def add_noise(imagePoints,sd=4,mean=0):
    gauss_noise= np.random.normal(mean,sd)
    imagePoints=imagePoints+gauss_noise
    return imagePoints           
    
    
   ### here we solve the problem using spherical coordinates and Euler angles


def a_b_c_from_Euler(Rot,Rt):
    world_position = get_world_position(Rt)  #[x,y,z,1]
    x = world_position[0]
    y = world_position[1]
    z = world_position[2]
    r = np.sqrt(x * x + y * y + z * z,dtype=np.float32)
    if r ==0:
        a = np.deg2rad(0.0)
    else:
        a = math.acos(z / r)
    if x == 0:
        b = np.deg2rad(90.0)
    else:
       b = math.atan(y / x)
    return a,b,r

def covariance_matrix_p(K,Rot,Rt,worldpoints,imagePoints):
    #xyz_sphere=xyz_sphere(a,b,r)
    a,b,c=a_b_c_from_Euler(Rot,Rt)
    Jac,JacT=jacobian_matrix(a,b,c,K,worldpoints)
    
    
    mean = 0.0
    scale = 4.0 
    size = 10000
    px1 = np.random.normal(mean, scale, size) + imagePoints[0, 0]
    py1 = np.random.normal(mean, scale, size) + imagePoints[0, 1]
    # Point 2
    px2 = np.random.normal(mean, scale, size) + imagePoints[1, 0]
    py2 = np.random.normal(mean, scale, size) + imagePoints[1, 1]
    # Point 3
    px3 = np.random.normal(mean, scale, size) + imagePoints[2, 0]
    py3 = np.random.normal(mean, scale, size) + imagePoints[2, 1]
    # Point 4
    px4 = np.random.normal(mean, scale, size) + imagePoints[3, 0]
    py4 = np.random.normal(mean, scale, size) + imagePoints[3, 1]
    # Point 5
    px5 = np.random.normal(mean, scale, size) + imagePoints[4, 0]
    py5 = np.random.normal(mean, scale, size) + imagePoints[4, 1]
    # Point 6
    px6 = np.random.normal(mean, scale, size) + imagePoints[5, 0]
    py6 = np.random.normal(mean, scale, size) + imagePoints[5, 1]
    
    cov_mat_p1 = np.cov(px1,py1)
    cov_mat_p2 = np.cov(px2,py2)
    cov_mat_p3 = np.cov(px3,py3)
    cov_mat_p4 = np.cov(px4,py4)
    cov_mat_p5 = np.cov(px5,py5)
    cov_mat_p6 = np.cov(px6,py6)
    
    
    
    image6points = np.block([[cov_mat_p1, np.zeros((2, 2)), np.zeros((2, 2)), np.zeros((2, 2)), np.zeros((2, 2)), np.zeros((2, 2))],
                                      [np.zeros((2, 2)), cov_mat_p2, np.zeros((2, 2)), np.zeros((2, 2)), np.zeros((2, 2)), np.zeros((2, 2))],
                                       [np.zeros((2, 2)), np.zeros((2, 2)), cov_mat_p3, np.zeros((2, 2)),np.zeros((2, 2)),np.zeros((2, 2))],
                                       [np.zeros((2, 2)), np.zeros((2, 2)),np.zeros((2, 2)),cov_mat_p4, np.zeros((2, 2)), np.zeros((2, 2))],
                                       [np.zeros((2, 2)), np.zeros((2, 2)),np.zeros((2, 2)),np.zeros((2, 2)), cov_mat_p5, np.zeros((2, 2))],
                                       [np.zeros((2, 2)), np.zeros((2, 2)),np.zeros((2, 2)),np.zeros((2, 2)), np.zeros((2, 2)), cov_mat_p6]])
    image6points=np.diag(np.diag( image6points))
    image6points=inv(image6points)
    cov_mat = inv(np.dot(np.dot(JacT,image6points), Jac))
    return cov_mat,image6points

def R_Euler(a,b,c):
    R_Eu= np.array([[math.cos(a)*math.cos(c) - math.cos(b)*math.sin(a)*math.sin(c), -math.cos(a)*math.sin(c)-math.cos(b)*math.cos(c)*math.sin(a), math.sin(a)*math.sin(b)],
                       [math.cos(c)*math.sin(a)+math.cos(a)*math.cos(b)*math.sin(c), math.cos(a)*math.cos(b)*math.cos(c)-math.sin(a)*math.sin(c), -math.cos(a)*math.sin(b)],
                       [math.sin(b)*math.sin(c), math.cos(c)*math.sin(b), math.cos(b)]])
    dR_Euler_da=np.array([[(-math.sin(a))*math.cos(c) - math.cos(b)*math.cos(a)*math.sin(c), (math.sin(a))*math.sin(c)-math.cos(b)*math.cos(c)*math.cos(a), math.cos(a)*math.sin(b)],
                       [math.cos(c)*math.cos(a)+(-math.sin(a))*math.cos(b)*math.sin(c), (-math.sin(a))*math.cos(b)*math.cos(c)-math.cos(a)*math.sin(c), math.sin(a)*math.sin(b)],
                       [0., 0.,0.]])
    dR_Euler_db=np.array([[math.sin(b)*math.sin(a)*math.sin(c), math.sin(b)*math.cos(c)*math.sin(a), math.sin(a)*math.cos(b)],
                       [math.cos(a)*(-math.sin(b))*math.sin(c), math.cos(a)*(-math.sin(b))*math.cos(c), -math.cos(a)*math.cos(b)],
                       [math.cos(b)*math.sin(c), math.cos(c)*math.cos(b), (-math.sin(b))]])
    dR_Euler_dc=np.array([[math.cos(a)*(-math.sin(c)) - math.cos(b)*math.sin(a)*math.cos(c), -math.cos(a)*math.cos(c)-math.cos(b)*(-math.sin(c))*math.sin(a),0.],
                       [(-math.sin(c))*math.sin(a)+math.cos(a)*math.cos(b)*math.cos(c), math.cos(a)*math.cos(b)*(-math.sin(c))-math.sin(a)*math.cos(c), 0.],
                       [math.sin(b)*math.cos(c), (-math.sin(c))*math.sin(b), 0.]])
    return R_Eu,dR_Euler_da,dR_Euler_db,dR_Euler_dc

def get_world_position(Rt):
        w_pos = np.dot(inv(Rt), np.array([0,0,0,1]))
        return w_pos
 
def jacobian_uv(X,P_da,P_db,P_dc):
     Y=np.array([[X[0]],
                [X[1]],
                [X[2]],
                [1]]) 
     image_point_da = np.dot(P_da,Y)
     image_point_db = np.dot(P_db,Y)
     image_point_dc = np.dot(P_dc,Y)
     u_da=  image_point_da[0]/ image_point_da[2]
     v_da=  image_point_da[1]/image_point_da[2]
     u_db=image_point_db[0]/image_point_db[2]
     v_db=image_point_db[1]/image_point_db[2]
     u_dc=image_point_dc[0]/image_point_dc[2]
     v_dc=image_point_dc[1]/image_point_dc[2]
     return float(u_da),float(u_db),float(u_dc),float(v_da),float(v_db),float(v_dc) #2*3
 
        #function for the jacobian matrix (spherical coordinates)
def jacobian_matrix(a,b,c,K,worldpoints):
    
     R_Sphere = np.array([[math.cos(b)*math.cos(a), -math.sin(b), math.cos(b)*math.sin(a)],
                       [math.sin(b)*math.cos(a), math.cos(b), math.sin(b)*math.sin(a)],
                       [math.sin(a), 0, math.cos(a)]])
     
     dR_da=np.array([ [math.cos(b)*(-math.sin(a)),0, math.cos(b)*math.cos(a)], #,c*(-math.cos(a))*math.cos(b),
                          [math.sin(b)*(-math.sin(a)), 0, math.sin(b)*math.cos(a)], #c*math.sin(b)*math.cos(a),
                          [(-math.sin(a)), 0,(-math.sin(a))] ]) #,c*(-math.sin(a))]])
     dR_db=np.array([[(-math.sin(b))*math.cos(a), -math.cos(b), (-math.sin(b))*math.sin(a)],
                          [math.cos(b)*math.cos(a), (-math.sin(b)),(-math.sin(b))*math.sin(a)],
                          [0., 0., 0.]])
     dR_dc=np.full((3,3),0.0) 
     R_Eu,dR_Euler_da,dR_Euler_db,dR_Euler_dc=R_Euler(0.0,np.deg2rad(180.0),0.0)
     R_Sphere_da=np.dot(dR_da,R_Eu)+np.dot(R_Sphere,dR_Euler_da)
     R_Sphere_db=np.dot(dR_db,R_Eu)+np.dot(R_Sphere,dR_Euler_db)
     R_Sphere_dc=np.dot(dR_dc,R_Eu)+np.dot(R_Sphere,dR_Euler_dc)
     R_Sphere = np.dot(R_Sphere, R_Eu[:3, :3])
     t_Sphere= np.array([[c*math.sin(a)*math.cos(b)],
            [c*math.sin(b)*math.sin(a)],
             [c*math.cos(a)]])
     t_da=np.array([[c*math.cos(a)*math.cos(b)],
            [c*math.sin(b)*math.cos(a)],
             [c*(-math.sin(a))]])
     t_db=np.array([[c*math.sin(a)*(-math.sin(b))],
            [c*math.cos(b)*math.sin(a)],
             [0.]])
     t_dc=np.array([[math.sin(a)*math.cos(b)],
            [math.sin(b)*math.sin(a)],
             [math.cos(a)]])
     t_Sphere_da=np.dot(R_Sphere_da, -t_Sphere)+np.dot(R_Sphere, -t_da)
     t_Sphere_db=np.dot(R_Sphere_db, -t_Sphere)+np.dot(R_Sphere, -t_db)
     t_Sphere_dc=np.dot(R_Sphere_dc, -t_Sphere)+np.dot(R_Sphere, -t_dc)
     t_Sphere=np.dot(R_Sphere,-t_Sphere)
     #Rt_Sphere=np.hstack((R_Sphere, t_Sphere))
     dRt_da=np.hstack((R_Sphere_da, t_Sphere_da))
     dRt_db=np.hstack((R_Sphere_db, t_Sphere_db))
     dRt_dc=np.hstack((R_Sphere_dc, t_Sphere_dc))
     P_da=np.dot(K,dRt_da)
     P_db=np.dot(K,dRt_db)
     P_dc=np.dot(K,dRt_dc)
     u1a,u1b,u1c,v1a,v1b,v1c=jacobian_uv(worldpoints[0,:],P_da,P_db,P_dc)
     u2a,u2b,u2c,v2a,v2b,v2c=jacobian_uv(worldpoints[1,:],P_da,P_db,P_dc)
     
     u4a,u4b,u4c,v4a,v4b,v4c=jacobian_uv(worldpoints[3,:],P_da,P_db,P_dc)
     u5a,u5b,u5c,v5a,v5b,v5c=jacobian_uv(worldpoints[4,:],P_da,P_db,P_dc)
     u6a,u6b,u6c,v6a,v6b,v6c=jacobian_uv(worldpoints[5,:],P_da,P_db,P_dc)
     u3a,u3b,u3c,v3a,v3b,v3c=jacobian_uv(worldpoints[2,:],P_da,P_db,P_dc)
     
        #3*12 JacTranspose
     JacT=np.array([[u1a,u2a,u3a,u4a,u5a,u6a,v1a,v2a,v3a,v4a,v5a,v6a],
                   [u1b,u2b,u3b,u4b,u5b,u6b,v1b,v2b,v3b,v4b,v5b,v6b],
                   [u1c,u2c,u3c,u4c,u5c,u6c,v1c,v2c,v3c,v4c,v5c,v6c]])
     
    
    #12*3 Jac
     Jac=np.array([[u1a,u1b,u1c],
                    [u2a,u2b,u2c],
                    [u3a,u3b,u3c],
                    [u4a,u4b,u4c],
                    [u5a,u5b,u5c],
                    [u6a,u6b,u6c],
                    [v1a,v1b,v1c],
                    [v2a,v2b,v2c],
                    [v3a,v3b,v3c],
                    [v4a,v4b,v4c],
                    [v5a,v5b,v5c],
                    [v6a,v6b,v6c]])
     #print JacT 
    
     return Jac,JacT
        
        
#values
P = np.eye(3,4)
R = np.eye(4, dtype=np.float32) # rotation
t = np.eye(4, dtype=np.float32) # translation
Rt = np.eye(4, dtype=np.float32)

K,P=set_K(Rt,fx = 600, fy = 600, cx = 320, cy = 240)
R,P=set_R_axisAngle(1.0,  0.0,  0.0, np.deg2rad(180.0),K,t)
t,P=set_t(0.0,-0.0,0.5,K,R, frame='world')


worldpoints = spherepoints(6)
#testpoints
#worldpoints = np.array([[-0.206674, 0.240009,-0.29203],
#                        [0.091502,-0.144823,	0.0323819],
 #                       [0.371293,	-0.458251	,0.269246],
  #                      [-0.864962	,0.222202	,0.0354375],
   #                     [-0.211795	,0.418585	,0.491078],
    #                    [-0.134308	,0.69774,	-0.773798]])

imagePoints=np.full((6,2),0.0)
imagePoints = project(worldpoints,P,imagePoints, False)
imagePoints=normalize(imagePoints)
imagepoints_noise=add_noise(imagePoints,2,0)



H= np.full((3,4),0.0)
trans=np.full((3,1), 0.0)
Rot=np.full((3,3), 0.0)

#NoNoiseTest
trans,Rot,H=DLT3D(worldpoints, imagePoints, K, True)
cond2=LA.cond(H)

#NoiseTest
trans,Rot,H=DLT3D(worldpoints, imagepoints_noise, K)
condnoise=LA.cond(H)   
#covnoise=np.cov(H)
 
Rt=set_afterDLT_Rt(trans,Rot)

covmatrix,imagecov=covariance_matrix_p(K,Rot,Rt,worldpoints,imagePoints)
    

