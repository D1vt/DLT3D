#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Sat Jan  5 15:41:33 2019
/
@author: diana
"""
from vision.camera import Camera
import random
import numpy as np 
from random import randrange
 

#use worldpoints from sphere
def spherepoints(points):
    worldpoints = np.random.randn(3, points)
    worldpoints /= np.linalg.norm(worldpoints, axis=0)
    return worldpoints

#DLT3D algorithm (2 cases normalize=False or = True 
def DLT3D(worldpoints, imagepoints, normalize=False):
    if (normalize):
        l = 0
        for j in range(12):
            if ((j % 2) == 0):                    #if even 0,0,0,0,xi,yi,zi,1,-vixi,-viyi,-vizi,-vi
                for k in range(4):
                            A[j, k] = 0
                A[j,4] = worldpoints[l,0]
                A[j,5] = worldpoints[l,1]
                A[j,6] = worldpoints[l,2]
                A[j,7] = 1
                A[j, 8] = -imagepoints[l, 1] * worldpoints[l,0]
                A[j, 9] = -imagepoints[l, 1] * worldpoints[l,1]
                A[j, 10] = -imagepoints[l, 1] * worldpoints[l,2]
                A[j, 11] = -imagepoints[l, 1]
            else :
             for k in range(4,8):
                A[j, k]= 0
             A[j,0] = worldpoints[l,0]
             A[j,1]= worldpoints[l,1]
             A[j,2] = worldpoints[l,2]
             A[j,3] = 1
             A[j, 8] = -imagepoints[l, 0] * worldpoints[l,0]
             A[j, 9] = -imagepoints[l, 0] * worldpoints[l,1]
             A[j, 10] = -imagepoints[l, 0] * worldpoints[l,2]
             A[j, 11] = -imagepoints[l, 0]
             l = l + 1
        U, s, V = np.linalg.svd(A, full_matrices=True)
        for i in range(12):
           M[i]=V[i,11]
        T[2]=M[11]/K[2,2]
        T[1]=(M[7]-K[1,2]*T[2])/K[1,1] 
        T[0]=(M[3]-K[0,1]*T[1]-K[0,2]*T[2])/K[0,0]
        for i in range(3):
          R[2,i]=M[i+8]/K[2,2]  #fr3i=m3i
          R[1,i]=(M[i+4]- R[2,i]*K[1,2])/K[1,1];  #dr2i+er3i=m2,i
          R[0,i]= (M[i]-K[0,2]*R[2,i]-K[0,1]*R[1,i])/K[0,0]; #ar1i+br2i+cr3i=m1i
        return T,R       
    else:
        normp= np.linalg.norm(imagepoints)
        normp=imagepoints/normp
        return DLT3D(worldpoints,normp, normalize=True)
 #function for the K matrix using random fx,cx,fy,cy    

worldpoints = spherepoints(6)
imagepoints=np.full((6, 2), 0.0)
A=np.full((12, 12), 0.0)
M=np.full((12, 1), 0.0)
T=np.full((3), 0.0)
R=np.full((3,3), 0.0)

## CREATE A SIMULATED CAMERA
cam_sim = Camera()
cam_sim.set_K(fx = 600,fy = 600,cx = 360,cy = 640)
cam_sim.set_width_heigth(960,960)
cam_sim.set_R_axisAngle(1.0,  0.0,  0.0, np.deg2rad(180.0))
cam_sim.set_t(0.0,-0.0,0.5, frame='world')
imagePoints = np.array(cam_sim.project(worldpoints, False))

#NoNoiseTest
T,R=DLT3D(worldpoints, imagePoints)

#NoiseTest
imagePoints_noise=imagePoints+np.random.normal(-10,10)
Tnoise,Rnoise=DLT3D(worldpoints, imagePoints)
   
    

 


    


